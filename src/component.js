// components take a childData array and a children array
// childData is an array of props for children
// each prop is an object with name, payload

/*
	childData = [
		{
			name: string,
			payload: any
		},
		...
	]
*/

// rendered components are passed to the document
// by calling Component.updateIfChildDataChanged(incomingChildData)
// where incomingChildData will be an array structured like childData
// childData should be delivered by a "hook" or some sort of
// side-effect fn that runs before the component subtree is built

class Component {
	constructor(childData = [], children = []) {
		this.childData = childData;
		this.children = children;
		this.ownSubtree = <div key={uuidv4()}></div>;
	}

	// this render method will allow us to pass
	// an ownSubtree to the Component instance
	// or it will default to a div wrapper
	// whose key is generated by default

	// custom Component instances that extend the Component class
	// will need to provide a key to ownSubtree

	buildComponentSubtree() {
		this.children.forEach(child => {
			// update child props
			const newProps = this.childData.find(
				propObject => propObject.name === child.props.name
			);

			child.props = newProps;
			this.ownSubtree.appendChild(child);
		});
	}

	// this method is the hook that re-renders the component
	// whenever incomingChildData has changed
	updateIfChildDataChanged(incomingChildData) {
		// if child data hasn't changed, ignore the update
		if (
			incomingChildData.length === this.childData.length &&
			incomingChildData.every(
				(child, idx) =>
					JSON.stringify(child) === JSON.stringify(this.childData[idx])
			)
		) {
			return;
		}

		// otherwise, set child data, build the component subtree, and return it
		this.childData = incomingChildData;
		this.buildComponentSubtree();
	}

	// this getter will pass this.ownSubtree
	// up to the Document
	getComponentSubtree() {
		return this.ownSubtree;
	}

	// this setter is used by CustomComponent's render() method
	setComponentSubtree(newSubtree) {
		this.ownSubtree = newSubtree;
	}
}

// until i have a better idea ...
// JSX will be initialized outside the CustomComponent
// and passed in directly to the constructor
// each file can contain CustomComponent state
// that can be used to selectively render the JSX
// by lazily evaluating it, so that
// we use the closure on the file to pull
// dynamic values in according to local component state

export class CustomComponent extends Component {
	constructor(childData, children, lazyGetJSX = () => null) {
		super(childData, children);
		this.jsx = lazyGetJSX();
	}

	beforeRender(newChildData) {
		this.updateIfChildDataChanged(newChildData);
	}

	// render sets tree and returns it
	render() {
		this.setComponentSubtree(this.jsx);
		return this.getComponentSubtree();
	}
}
