// components take a childData array and a children array
// childData is an array of props for children
// each prop is an object with name, payload

/*
	childData = [
		{
			name: string,
			payload: any
		},
		...
	]
*/

// rendered components are passed to the document
// by calling Component.updateIfChildDataChanged(incomingChildData)
// where incomingChildData will be an array structured like childData
// childData should be delivered by a "hook" or some sort of
// side-effect fn that runs before the component subtree is built

// this.ownSubtree is generated by DOMParser.parseFromString(ownSubtreeString, 'text/html')
const parser = new DOMParser();

export class Component {
	constructor(childData = [], children = [], ownSubtreeString) {
		this.childData = childData;
		this.children = children;
		this.ownSubtree = (() => {
			const newDocFragment = parser.parseFromString(
				ownSubtreeString,
				'text/html'
			);

			// hack until i figure out how to only generate the subtree
			// and not the html, body surrounding it ...
			return newDocFragment.querySelector('body *');
		})();
	}

	// this render method will allow us to pass
	// an ownSubtree to the Component instance
	// or it will default to a div wrapper
	// whose key is generated by default

	// custom Component instances that extend the Component class
	// will need to provide a key to ownSubtree

	buildComponentSubtree() {
		this.children.forEach(child => {
			// update child props
			const newProps = this.childData.find(
				propObject => propObject.name === child.props.name
			);

			child.props = newProps;
			this.ownSubtree.appendChild(child);
		});
	}

	// this method is the hook that re-renders the component
	// whenever incomingChildData has changed
	updateIfChildDataChanged(incomingChildData) {
		// if child data hasn't changed, ignore the update
		if (
			incomingChildData.length === this.childData.length &&
			incomingChildData.every(
				(child, idx) =>
					JSON.stringify(child) === JSON.stringify(this.childData[idx])
			)
		) {
			return;
		}

		// otherwise, set child data, build the component subtree, and return it
		this.childData = incomingChildData;
		this.buildComponentSubtree();
	}

	getComponentSubtree() {
		return this.ownSubtree;
	}

	setComponentSubtree(newSubtree) {
		this.ownSubtree = newSubtree;
	}
}
